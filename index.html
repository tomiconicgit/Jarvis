<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Mobile 3D Modeler — Tower Base (CSG Build Fix)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html,body{margin:0;padding:0;overflow:hidden;height:100%;width:100%;background:#111;font-family:Inter,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif}
    #canvas-container{position:fixed;inset:0;z-index:1}
    canvas{display:block;width:100%;height:100%}
    *{-webkit-tap-highlight-color:transparent;user-select:none;-webkit-user-select:none}
    #loading-screen{position:fixed;inset:0;background:#1a1a1a;color:#fff;display:flex;justify-content:center;align-items:center;font-size:1.5rem;z-index:1000;transition:opacity .5s ease}
    .ui-panel{position:fixed;background:rgba(30,30,30,.85);backdrop-filter:blur(10px);-webkit-backdrop-filter:blur(10px);border-radius:12px;z-index:10;transition:transform .3s ease-out,opacity .3s ease-out;box-shadow:0 8px 20px rgba(0,0,0,.3)}
    input[type="range"]{-webkit-appearance:none;appearance:none;width:100%;height:8px;background:#4a5568;border-radius:4px}
    input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:24px;height:24px;background:#3b82f6;border-radius:50%;border:2px solid #fff;box-shadow:0 0 5px rgba(0,0,0,.5)}
    input[type="range"]::-moz-range-thumb{width:24px;height:24px;background:#3b82f6;border-radius:50%;border:2px solid #fff;box-shadow:0 0 5px rgba(0,0,0,.5)}
    #message-box{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%) scale(.9);background:rgba(40,40,40,.9);color:#fff;padding:20px 30px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,.4);z-index:1001;opacity:0;visibility:hidden;transition:all .2s ease-out;text-align:center;backdrop-filter:blur(5px)}
    #message-box.show{transform:translate(-50%,-50%) scale(1);opacity:1;visibility:visible}
  </style>
</head>
<body class="bg-gray-900 text-white">
  <div id="canvas-container"></div>
  <div id="loading-screen"><div>Loading 3D Environment...</div></div>
  <div id="message-box"><p id="message-text">This is a message!</p></div>

  <div class="ui-panel bottom-4 left-1/2 -translate-x-1/2 flex items-center space-x-4 p-3 rounded-full">
    <button id="add-btn" class="w-14 h-14 bg-blue-600 rounded-full flex justify-center items-center shadow-lg active:scale-90 transition-transform">
      <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6v12M6 12h12"/></svg>
    </button>
    <button id="tools-btn" class="w-14 h-14 bg-gray-700 rounded-full flex justify-center items-center shadow-lg active:scale-90 transition-transform">
      <svg class="w-7 h-7" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z"/></svg>
    </button>
  </div>

  <div id="add-panel" class="ui-panel bottom-24 left-4 right-4 p-4 transform translate-y-full opacity-0" style="visibility:hidden;">
    <h3 class="text-lg font-bold mb-4">Add Object</h3>
    <div class="grid grid-cols-3 gap-4">
      <button id="add-tower-btn" class="bg-gray-700 p-3 rounded-lg flex flex-col items-center active:scale-90 transition-transform">
        <svg class="w-12 h-12 mb-1" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M20 7l-8-4-8 4m16 0l-8 4m8-4v10l-8 4M4 7v10l8 4M4 7l8 4"/></svg>
        <span class="text-xs font-medium">Tower Base</span>
      </button>
    </div>
    <button id="close-add-panel" class="absolute top-2 right-2 w-8 h-8 bg-gray-600 rounded-full flex justify-center items-center">&times;</button>
  </div>

  <div id="props-panel" class="ui-panel top-4 right-4 w-72 max-w-[80vw] max-h-[90vh] p-4 transform translate-x-full opacity-0" style="visibility:hidden;">
    <div class="flex justify-between items-center mb-4">
      <h3 class="text-lg font-bold">Properties</h3>
      <button id="close-props-panel" class="w-8 h-8 bg-gray-600 rounded-full flex justify-center items-center">&times;</button>
    </div>
    <div id="props-content" class="space-y-4 overflow-y-auto max-h-[75vh] pr-2"></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/TransformControls.js"></script>

  <script src="./csg-lib.js"></script>

  <script>
    // ---------- Globals ----------
    let scene, camera, renderer, orbitControls, transformControls;
    let raycaster, touchStartPos, currentSelection, allModels;
    let loadingScreen, canvasContainer, addBtn, addPanel, closeAddPanel;
    let propsPanel, closePropsPanel, propsContent, addTowerBtn;
    let lastTapTime = 0; const DOUBLE_TAP_DELAY = 300;

    // ---------- Init ----------
    function init(){
      loadingScreen = document.getElementById('loading-screen');
      canvasContainer = document.getElementById('canvas-container');
      addBtn = document.getElementById('add-btn');
      addPanel = document.getElementById('add-panel');
      closeAddPanel = document.getElementById('close-add-panel');
      propsPanel = document.getElementById('props-panel');
      closePropsPanel = document.getElementById('close-props-panel');
      propsContent = document.getElementById('props-content');
      addTowerBtn = document.getElementById('add-tower-btn');

      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x2a2a2a);
      scene.fog = new THREE.Fog(0x2a2a2a, 50, 200);

      renderer = new THREE.WebGLRenderer({ antialias:true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      canvasContainer.appendChild(renderer.domElement);

      camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.set(15,20,25);

      scene.add(new THREE.AmbientLight(0x808080));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(10,20,5); dir.castShadow = true; dir.shadow.mapSize.set(1024,1024);
      scene.add(dir);

      scene.add(new THREE.GridHelper(100,100,0x888888,0x444444));

      const ground = new THREE.Mesh(new THREE.PlaneGeometry(100,100), new THREE.MeshStandardMaterial({color:0x3a3a3a, roughness:1}));
      ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

      orbitControls = new THREE.OrbitControls(camera, renderer.domElement);
      orbitControls.enableDamping = true; orbitControls.dampingFactor = .1; orbitControls.enablePan = true;

      transformControls = new THREE.TransformControls(camera, renderer.domElement);
      transformControls.setMode("translate");
      transformControls.addEventListener('dragging-changed', e => { orbitControls.enabled = !e.value; });
      scene.add(transformControls);

      raycaster = new THREE.Raycaster();
      touchStartPos = new THREE.Vector2();
      allModels = [];

      window.addEventListener('resize', onWindowResize);
      canvasContainer.addEventListener('touchstart', onTouchStart, {passive:false});
      canvasContainer.addEventListener('touchend', onTouchEnd);

      initUI();

      loadingScreen.style.opacity='0';
      setTimeout(()=>loadingScreen.style.display='none', 500);

      animate();
    }

    function animate(){ requestAnimationFrame(animate); orbitControls.update(); renderer.render(scene,camera); }

    // ---------- Events ----------
    function onWindowResize(){
      camera.aspect = window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }
    function onTouchStart(e){ e.preventDefault(); if(e.touches.length===1){const t=e.touches[0]; touchStartPos.set(t.clientX,t.clientY);} }
    function onTouchEnd(e){
      if(e.changedTouches.length===1){
        const t=e.changedTouches[0]; const endPos = new THREE.Vector2(t.clientX,t.clientY);
        if(touchStartPos.distanceTo(endPos)<10){
          const now=Date.now();
          if(now-lastTapTime<DOUBLE_TAP_DELAY) handleDoubleTap(t); else handleSingleTap(t);
          lastTapTime=now;
        }
      }
    }
    function getTouchNDC(t){return {x:(t.clientX/window.innerWidth)*2-1, y:-(t.clientY/window.innerHeight)*2+1};}
    function handleSingleTap(t){
      const ndc=getTouchNDC(t); raycaster.setFromCamera(ndc,camera);
      const hits = raycaster.intersectObjects(allModels,true);
      if(hits.length){
        let obj=hits[0].object; while(obj.parent && obj.parent.userData.isModel) obj=obj.parent;
        selectObject(obj);
      } else deselectAll();
    }
    function handleDoubleTap(t){
      const ndc=getTouchNDC(t); raycaster.setFromCamera(ndc,camera);
      const hits = raycaster.intersectObjects(allModels,true);
      if(hits.length){
        const box=new THREE.Box3().setFromObject(hits[0].object);
        orbitControls.target.copy(box.getCenter(new THREE.Vector3()));
        showTempMessage("Camera Focused");
      }
    }
    function selectObject(o){ if(currentSelection===o) return; currentSelection=o; transformControls.attach(o); updatePropsPanel(o); showPanel(propsPanel); }
    function deselectAll(){ if(currentSelection) transformControls.detach(); currentSelection=null; hidePanel(propsPanel); }

    function initUI(){
      addBtn.addEventListener('click', ()=>{showPanel(addPanel); hidePanel(propsPanel);});
      closeAddPanel.addEventListener('click', ()=>hidePanel(addPanel));
      closePropsPanel.addEventListener('click', ()=>deselectAll());
      document.getElementById('tools-btn').addEventListener('click', ()=>{
        if(!currentSelection) return showTempMessage("Select an object first");
        const m = transformControls.getMode();
        transformControls.setMode(m==="translate"?"rotate":m==="rotate"?"scale":"translate");
        showTempMessage(`Mode: ${transformControls.getMode()[0].toUpperCase()+transformControls.getMode().slice(1)}`);
      });

      // Add Tower Base with door
      addTowerBtn.addEventListener('click', ()=>{
        const params = {
          width: 12,
          depth: 12,
          height: 6,
          wallThickness: 1,
          cornerRadius: 1.2,      // vertical edge roundness (footprint)
          cornerSmoothness: 16,   // curveSegments for footprint
          // edgeRoundness: 0.3,  // Bevels are disabled in this approach for simplicity
          // edgeSmoothness: 4,
          doorWidth: 4,
          doorHeight: 3
        };
        const tower = new TowerBase(params);
        // tower.position.y = params.height/2; // Position is now set inside build()
        scene.add(tower); allModels.push(tower); selectObject(tower); hidePanel(addPanel);
      });
    }

    function showPanel(p){ p.style.visibility='visible'; p.style.opacity='1'; p.style.transform=p.id.includes('props')?'translateX(0)':'translateY(0)'; }
    function hidePanel(p){ p.style.opacity='0'; p.style.transform=p.id.includes('props')?'translateX(100%)':'translateY(100%)'; setTimeout(()=>p.style.visibility='hidden',300); }
    function showTempMessage(text){ const box=document.getElementById('message-box'); document.getElementById('message-text').textContent=text; box.classList.add('show'); setTimeout(()=>box.classList.remove('show'),1500); }

    // ---------- Geometry helpers ----------
    // Creates a rounded box geometry
    // ⚠️ FIXED TYPO HERE ⚠️
    function createRoundedBox(width, height, depth, radiusParam, smoothness) { // Renamed parameter
      const shape = new THREE.Shape();
      const eps = 0.00001;
      const radius = Math.max(radiusParam || eps, eps); // Use radiusParam here and ensure minimum > 0

      // Use the calculated 'radius' for the shape definition
      shape.moveTo(-width / 2 + radius, -depth / 2);
      shape.lineTo(width / 2 - radius, -depth / 2);
      shape.absarc(width / 2 - radius, -depth / 2 + radius, radius, -Math.PI / 2, 0, false);
      shape.lineTo(width / 2, depth / 2 - radius);
      shape.absarc(width / 2 - radius, depth / 2 - radius, radius, 0, Math.PI / 2, false);
      shape.lineTo(-width / 2 + radius, depth / 2);
      shape.absarc(-width / 2 + radius, depth / 2 - radius, radius, Math.PI / 2, Math.PI, false);
      shape.lineTo(-width / 2, -depth / 2 + radius);
      shape.absarc(-width / 2 + radius, -depth / 2 + radius, radius, Math.PI, 1.5 * Math.PI, false);
      shape.closePath();

      const extrudeSettings = {
        depth: height,
        bevelEnabled: false, // Keep it simple for CSG
        curveSegments: Math.max(1, Math.floor(smoothness / 4)) || 8 // Use fewer segments for extrusion
      };

      const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
      geo.translate(0, 0, -height / 2); // Center Z
      geo.rotateX(-Math.PI / 2);      // Make Y up
      geo.computeVertexNormals();
      return geo;
    }


    // door safe limits (simplified for BoxGeometry)
    function maxDoorWidth(p){
      const eps=0.05;
      // Subtract corner radius approximation
      const safeWidth = p.width - 2 * p.cornerRadius;
      return Math.max(eps, safeWidth - eps);
    }
    function maxDoorHeight(p){
      const eps=0.05;
      return Math.max(eps, p.height - eps);
    }

    // This function will find the 'threecsg' variable loaded by csg-lib.js
    function getCSG(){
      const ns = window.threecsg || window.CSG || window.__THREE_CSG_MESH__ || window['three-csgmesh'];
      return ns && (ns.fromMesh && ns.toMesh && ns.subtract ? ns :
                    ns.CSG && ns.CSG.fromMesh ? ns.CSG : null);
    }

    // ---------- Unified model (Tower Base) ----------
    class TowerBase extends THREE.Group{
      constructor(params){
        super();
        this.userData.isModel = true;
        this.userData.type = 'TowerBase';
        this.userData.params = {...params};
        this.material = new THREE.MeshStandardMaterial({color:0xcccccc, roughness:0.7, metalness:0.1});
        this.build();
      }

      build(){
        // Dispose old children first
        while(this.children.length > 0){
          const child = this.children[0];
          this.remove(child);
          if(child.geometry) child.geometry.dispose();
          // Note: Material is shared, so don't dispose it here
        }

        const p = this.userData.params;
        const CSG = getCSG();
        if(!CSG){
          console.error('CSG library not loaded! Cannot build TowerBase.');
          // Maybe add a placeholder or error indicator mesh?
          return;
        }

        let finalMesh = null; // Declare finalMesh outside try block

        try {
          // --- 1. Create Outer Shell ---
          const outerRadius = Math.max(0.01, p.cornerRadius);
          const outerGeo = createRoundedBox(p.width, p.height, p.depth, outerRadius, p.cornerSmoothness);
          const outerMesh = new THREE.Mesh(outerGeo); // No need for material here
          outerMesh.updateMatrix(); // Update matrix BEFORE CSG operations

          // --- 2. Create Inner Shell (to subtract) ---
          const innerW = Math.max(0.1, p.width - 2 * p.wallThickness);
          const innerD = Math.max(0.1, p.depth - 2 * p.wallThickness);
          const innerH = p.height; // Use full height to ensure clean top/bottom
          const innerRadius = Math.max(0.01, outerRadius - p.wallThickness); // Use outerRadius as base
          const innerGeo = createRoundedBox(innerW, innerH, innerD, innerRadius, p.cornerSmoothness);
          const innerMesh = new THREE.Mesh(innerGeo);
          innerMesh.updateMatrix();

          // --- 3. Subtract Inner from Outer ---
          const shellCSG = CSG.subtract(CSG.fromMesh(outerMesh), CSG.fromMesh(innerMesh));
          // Don't convert back to mesh yet, keep as CSG object

          // Dispose temporary geometries used for shell subtraction
          outerGeo.dispose();
          innerGeo.dispose();


          // --- 4. Create Door Cutter ---
          const cutDepth = p.wallThickness * 3.0;
          const doorW = Math.min(p.doorWidth || 4, maxDoorWidth(p));
          const doorH = Math.min(p.doorHeight || 3, maxDoorHeight(p));
          const doorGeo = new THREE.BoxGeometry(doorW, doorH, cutDepth);
          const doorMesh = new THREE.Mesh(doorGeo);

          // Position the door cutter (relative to the origin where the shell CSG is)
          const doorY = -p.height/2 + doorH/2;
          const doorZ = p.depth / 2 - p.wallThickness / 2;
          doorMesh.position.set(0, doorY, doorZ);
          doorMesh.updateMatrix();


          // --- 5. Subtract Door from Shell CSG Object ---
          const finalCSG = CSG.subtract(shellCSG, CSG.fromMesh(doorMesh)); // Subtract directly from shellCSG

          // Dispose temporary door geometry
          doorGeo.dispose();

          // --- 6. Convert Final CSG to Mesh ---
          // Use identity matrix because transformations are handled by the group
          finalMesh = CSG.toMesh(finalCSG, new THREE.Matrix4(), this.material);
          finalMesh.geometry.computeVertexNormals();

          // Position the final mesh correctly
          finalMesh.position.y = p.height / 2;
          finalMesh.castShadow = true;
          finalMesh.receiveShadow = true;
          this.add(finalMesh); // Add the final result

        } catch(err) {
            console.error('CSG operation failed during build:', err);
            // Fallback: Create a simple red box
             const fallbackGeo = new THREE.BoxGeometry(p.width, p.height, p.depth);
             const fallbackMesh = new THREE.Mesh(fallbackGeo, new THREE.MeshStandardMaterial({color: 0xff0000}));
             fallbackMesh.position.y = p.height/2;
             this.add(fallbackMesh);
             finalMesh = fallbackMesh; // Assign fallback to finalMesh if needed elsewhere
        } finally {
            // Optional: Clean up intermediate meshes if they exist (though maybe disposed above)
            // if (shellResultMesh) this.remove(shellResultMesh); // Example if added temporarily
        }
      }

      updateParams(next){
        next = {...next};
        // Re-clamp parameters
        const crMax = Math.max(0.01, Math.min(next.width, next.depth)/2 - next.wallThickness - 0.01);
         if(next.cornerRadius < 0) next.cornerRadius = 0; // Ensure non-negative
         if(next.cornerRadius > crMax) next.cornerRadius = crMax;

        const dwMax = maxDoorWidth(next);
        const dhMax = maxDoorHeight(next);
         if(next.doorWidth < 0.1) next.doorWidth = 0.1; // Ensure min size
         if(next.doorWidth  > dwMax) next.doorWidth  = dwMax;
         if(next.doorHeight < 0.1) next.doorHeight = 0.1; // Ensure min size
         if(next.doorHeight > dhMax) next.doorHeight = dhMax;

        this.userData.params = next;
        this.build();
      }
    }

    // ---------- Properties UI ----------
    function cornerRadiusMaxUI(p){
      const eps=0.01; return Math.max(0, Math.min(p.width, p.depth)/2 - p.wallThickness - eps);
    }

    function updatePropsPanel(object){
      propsContent.innerHTML = '';
      if(!object || !object.userData.params){
        propsContent.innerHTML = '<p class="text-gray-400">No parameters to edit.</p>'; return;
      }
      const p = object.userData.params;
      const paramConfig = {
        height:          { min:1,   max:40, step:0.1, label:'Height' },
        width:           { min:4,   max:60, step:0.1, label:'Width' },
        depth:           { min:4,   max:60, step:0.1, label:'Depth' },
        wallThickness:   { min:0.1, max:5,  step:0.1, label:'Wall Thickness' },
        cornerRadius:    { min:0,   max:cornerRadiusMaxUI(p), step:0.05, label:'Corner Radius' },
        cornerSmoothness:{ min:8,   max:64, step:1,   label:'Corner Smoothness' },
        doorWidth:       { min:0.5, max:maxDoorWidth(p),  step:0.1, label:'Door Width' },
        doorHeight:      { min:0.5, max:maxDoorHeight(p), step:0.1, label:'Door Height' }
      };

      for(const key in paramConfig){
        const cfg = paramConfig[key];
        // Dynamically set max values based on current params 'p'
        if(key==='cornerRadius') cfg.max = cornerRadiusMaxUI(p);
        if(key==='doorWidth') cfg.max = maxDoorWidth(p);
        if(key==='doorHeight') cfg.max = maxDoorHeight(p);

        const value = (p[key] ?? cfg.min);
        const valueFmt = (cfg.step>=1) ? Math.round(value) : value.toFixed(2);
        const html = `
          <div class="space-y-1">
            <label class="text-sm font-medium text-gray-300 flex justify-between">
              <span>${cfg.label}</span>
              <span id="${key}-value">${valueFmt}</span>
            </label>
            <input type="range" id="${key}-slider" data-param="${key}"
              min="${cfg.min}" max="${cfg.max}" step="${cfg.step}" value="${value}">
          </div>`;
        propsContent.insertAdjacentHTML('beforeend', html);
      }

      propsContent.querySelectorAll('input[type="range"]').forEach(slider=>{
        slider.addEventListener('input', ()=>{
          const key = slider.dataset.param;
          const cfg = paramConfig[key];
          const val = (cfg.step>=1) ? Math.round(parseFloat(slider.value)) : parseFloat(slider.value);
          // Use a temporary 'next' object to calculate interdependent max values correctly
          const next = {...object.userData.params, [key]: val};

          // Update max values of sliders based on the *potential* new value
          if(key==='width' || key==='depth' || key==='wallThickness'){
            const crSlider = document.getElementById('cornerRadius-slider');
            if(crSlider){ const maxCR = cornerRadiusMaxUI(next); crSlider.max = maxCR; }
            const dwSlider = document.getElementById('doorWidth-slider');
            if(dwSlider){ const maxDW = maxDoorWidth(next); dwSlider.max = maxDW; }
          }
           if(key==='cornerRadius'){
             const dwSlider = document.getElementById('doorWidth-slider');
             if(dwSlider){ const maxDW = maxDoorWidth(next); dwSlider.max = maxDW; }
           }
          if(key==='height'){
            const dhSlider = document.getElementById('doorHeight-slider');
            if(dhSlider){ const maxDH = maxDoorHeight(next); dhSlider.max = maxDH; }
          }

          // Update the label for the current slider
          const lbl = document.getElementById(`${key}-value`);
          if(lbl) lbl.textContent = (cfg.step>=1) ? Math.round(val) : val.toFixed(2);

          // Now, actually update the object's parameters and rebuild
          object.updateParams(next); // This will re-trigger build()
        });
      });
    }

    // ---------- bootstrap ----------
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
